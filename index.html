<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="theme-color" content="#ffffff" media="(prefers-color-scheme: light)">
  <meta name="theme-color" content="#0a0a0a" media="(prefers-color-scheme: dark)">
  <link rel="manifest" href="manifest.json">
  <title>Textarea</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Crimson+Pro:wght@400;600;700&family=Space+Mono:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --bg-primary: #fafafa;
      --bg-secondary: #ffffff;
      --bg-tertiary: #f5f5f5;
      --text-primary: #1a1a1a;
      --text-secondary: #666666;
      --border-color: #e0e0e0;
      --accent: #2563eb;
      --accent-hover: #1d4ed8;
      --toolbar-bg: rgba(255, 255, 255, 0.95);
      --shadow: rgba(0, 0, 0, 0.08);
      --shadow-lg: rgba(0, 0, 0, 0.12);
    }

    @media (prefers-color-scheme: dark) {
      :root {
        --bg-primary: #0a0a0a;
        --bg-secondary: #151515;
        --bg-tertiary: #1a1a1a;
        --text-primary: #f5f5f5;
        --text-secondary: #a0a0a0;
        --border-color: #2a2a2a;
        --accent: #3b82f6;
        --accent-hover: #60a5fa;
        --toolbar-bg: rgba(21, 21, 21, 0.95);
        --shadow: rgba(0, 0, 0, 0.4);
        --shadow-lg: rgba(0, 0, 0, 0.6);
      }
    }

    html {
      color-scheme: light dark;
      -webkit-font-smoothing: antialiased;
      text-rendering: optimizeLegibility;
      background-color: var(--bg-primary);
    }

    body {
      color: var(--text-primary);
      font-family: 'Crimson Pro', Georgia, serif;
      overflow-x: hidden;
    }

    /* Top Navigation */
    .top-nav {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      height: 60px;
      background: var(--toolbar-bg);
      backdrop-filter: blur(20px);
      border-bottom: 1px solid var(--border-color);
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0 24px;
      z-index: 100;
      transition: transform 0.3s ease;
    }

    .top-nav.hidden {
      transform: translateY(-100%);
    }

    .logo {
      font-family: 'Space Mono', monospace;
      font-weight: 700;
      font-size: 18px;
      color: var(--text-primary);
      text-decoration: none;
      letter-spacing: -0.5px;
    }

    .nav-actions {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .nav-btn {
      padding: 8px 16px;
      background: transparent;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      color: var(--text-primary);
      font-family: 'Space Mono', monospace;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .nav-btn:hover {
      background: var(--bg-tertiary);
      border-color: var(--text-secondary);
    }

    .nav-btn.primary {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    .nav-btn.primary:hover {
      background: var(--accent-hover);
      border-color: var(--accent-hover);
    }

    /* Editor Container */
    .editor-container {
      margin-top: 60px;
      min-height: calc(100vh - 140px);
      padding: 40px max(40px, calc(50vw - 450px));
    }

    article {
      outline: none;
      width: 100%;
      min-height: calc(100vh - 220px);
      font-size: 19px;
      line-height: 1.7;
      tab-size: 4;
      white-space: pre-wrap;
      text-wrap-style: stable;
      overflow-wrap: break-word;
      padding: 20px;
      background: var(--bg-secondary);
      border-radius: 12px;
      border: 1px solid var(--border-color);
      transition: all 0.3s ease;
    }

    article:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1);
    }

    /* Bottom Toolbar */
    .bottom-toolbar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--toolbar-bg);
      backdrop-filter: blur(20px);
      border-top: 1px solid var(--border-color);
      padding: 12px 24px;
      display: flex;
      align-items: center;
      justify-content: space-between;
      z-index: 100;
      transition: transform 0.3s ease;
    }

    .bottom-toolbar.hidden {
      transform: translateY(100%);
    }

    .format-tools {
      display: flex;
      gap: 4px;
      flex-wrap: wrap;
    }

    .format-btn {
      padding: 8px 12px;
      background: transparent;
      border: 1px solid transparent;
      border-radius: 6px;
      color: var(--text-primary);
      font-family: 'Space Mono', monospace;
      font-size: 13px;
      cursor: pointer;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      gap: 6px;
      min-width: 40px;
      justify-content: center;
    }

    .format-btn:hover {
      background: var(--bg-tertiary);
      border-color: var(--border-color);
    }

    .format-btn.active {
      background: var(--accent);
      color: white;
      border-color: var(--accent);
    }

    .format-divider {
      width: 1px;
      height: 24px;
      background: var(--border-color);
      margin: 0 8px;
    }

    .stats {
      font-family: 'Space Mono', monospace;
      font-size: 12px;
      color: var(--text-secondary);
      display: flex;
      gap: 16px;
    }

    /* Markdown Styles */
    .md-h1, .md-h2, .md-h3, .md-h4, .md-h5, .md-h6 {
      font-weight: 700;
      line-height: 1.3;
      margin: 0.5em 0;
    }

    .md-h1 { font-size: 2.2em; }
    .md-h2 { font-size: 1.8em; }
    .md-h3 { font-size: 1.5em; }
    .md-h4 { font-size: 1.25em; }
    .md-h5 { font-size: 1.1em; }
    .md-h6 { font-size: 1em; color: var(--text-secondary); }

    .md-code {
      font-family: 'Space Mono', monospace;
      background: var(--bg-tertiary);
      padding: 2px 6px;
      border-radius: 4px;
      font-size: 0.9em;
    }

    .md-codeblock {
      font-family: 'Space Mono', monospace;
      background: var(--bg-tertiary);
      padding: 16px;
      border-radius: 8px;
      display: block;
      overflow-x: auto;
      margin: 1em 0;
      border: 1px solid var(--border-color);
    }

    .md-bold { font-weight: 700; }
    .md-italic { font-style: italic; }
    .md-strike { text-decoration: line-through; opacity: 0.7; }
    
    .md-url {
      cursor: pointer;
      color: var(--accent);
      text-decoration: underline;
      text-underline-offset: 3px;
    }

    .md-url:hover {
      color: var(--accent-hover);
    }

    /* Dropdown Menu */
    .dropdown {
      position: relative;
    }

    .dropdown-menu {
      position: absolute;
      top: calc(100% + 8px);
      right: 0;
      background: var(--bg-secondary);
      border: 1px solid var(--border-color);
      border-radius: 10px;
      box-shadow: 0 10px 40px var(--shadow-lg);
      min-width: 200px;
      opacity: 0;
      visibility: hidden;
      transform: translateY(-10px);
      transition: all 0.2s ease;
      overflow: hidden;
      z-index: 1000;
    }

    .dropdown-menu.show {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    .dropdown-item {
      padding: 12px 16px;
      display: flex;
      align-items: center;
      gap: 10px;
      cursor: pointer;
      color: var(--text-primary);
      text-decoration: none;
      font-family: 'Space Mono', monospace;
      font-size: 13px;
      transition: background 0.15s ease;
      border: none;
      background: none;
      width: 100%;
      text-align: left;
    }

    .dropdown-item:hover {
      background: var(--bg-tertiary);
    }

    .dropdown-item:first-child {
      border-top-left-radius: 10px;
      border-top-right-radius: 10px;
    }

    .dropdown-item:last-child {
      border-bottom-left-radius: 10px;
      border-bottom-right-radius: 10px;
    }

    /* Notification */
    .notification {
      position: fixed;
      top: 80px;
      right: 24px;
      background: var(--accent);
      color: white;
      padding: 12px 20px;
      border-radius: 10px;
      font-family: 'Space Mono', monospace;
      font-size: 14px;
      font-weight: 600;
      box-shadow: 0 10px 40px var(--shadow-lg);
      opacity: 0;
      visibility: hidden;
      transform: translateY(-20px);
      transition: all 0.3s ease;
      z-index: 1000;
    }

    .notification.show {
      opacity: 1;
      visibility: visible;
      transform: translateY(0);
    }

    /* Format Selector */
    .format-selector {
      font-family: 'Space Mono', monospace;
      font-size: 13px;
      padding: 8px 12px;
      background: transparent;
      border: 1px solid var(--border-color);
      border-radius: 6px;
      color: var(--text-primary);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .format-selector:hover {
      background: var(--bg-tertiary);
    }

    /* Responsive */
    @media (max-width: 768px) {
      .top-nav {
        padding: 0 16px;
      }

      .editor-container {
        padding: 24px 16px;
      }

      .bottom-toolbar {
        padding: 8px 16px;
        flex-direction: column;
        gap: 8px;
        align-items: stretch;
      }

      .format-tools {
        justify-content: center;
      }

      .stats {
        justify-content: center;
      }

      .nav-actions {
        gap: 4px;
      }

      .nav-btn span {
        display: none;
      }
    }

    @media print {
      .top-nav,
      .bottom-toolbar,
      .noprint {
        display: none !important;
      }

      .editor-container {
        margin: 0;
        padding: 0;
      }

      article {
        border: none;
        background: white;
      }
    }

    /* Icon styles */
    .icon {
      width: 18px;
      height: 18px;
      stroke: currentColor;
      fill: none;
      stroke-width: 2;
      stroke-linecap: round;
      stroke-linejoin: round;
    }
  </style>
</head>
<body>
  <!-- Top Navigation -->
  <nav class="top-nav">
    <a href="#new" class="logo">Textarea</a>
    <div class="nav-actions">
      <button class="nav-btn" id="newDoc">
        <svg class="icon" viewBox="0 0 24 24"><path d="M12 5v14M5 12h14"/></svg>
        <span>New</span>
      </button>
      <button class="nav-btn" id="shareBtn">
        <svg class="icon" viewBox="0 0 24 24"><path d="M8 9h-1a2 2 0 0 0 -2 2v8a2 2 0 0 0 2 2h10a2 2 0 0 0 2 -2v-8a2 2 0 0 0 -2 -2h-1M12 14v-11M9 6l3 -3l3 3"/></svg>
        <span>Share</span>
      </button>
      <div class="dropdown">
        <button class="nav-btn primary" id="menuBtn">
          <svg class="icon" viewBox="0 0 24 24"><circle cx="12" cy="12" r="1"/><circle cx="12" cy="5" r="1"/><circle cx="12" cy="19" r="1"/></svg>
          <span>Menu</span>
        </button>
        <div class="dropdown-menu" id="mainMenu">
          <button class="dropdown-item" id="qrBtn">
            <svg class="icon" viewBox="0 0 24 24"><path d="M4 5a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1M14 5a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1M4 15a1 1 0 0 1 1 -1h4a1 1 0 0 1 1 1v4a1 1 0 0 1 -1 1h-4a1 1 0 0 1 -1 -1"/></svg>
            Generate QR
          </button>
          <button class="dropdown-item" id="saveHTML">
            <svg class="icon" viewBox="0 0 24 24"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"/><polyline points="17 21 17 13 7 13 7 21"/><polyline points="7 3 7 8 15 8"/></svg>
            Save as HTML
          </button>
          <button class="dropdown-item" id="saveTXT">
            <svg class="icon" viewBox="0 0 24 24"><path d="M14 3v4a1 1 0 0 0 1 1h4"/><path d="M17 21h-10a2 2 0 0 1 -2 -2v-14a2 2 0 0 1 2 -2h7l5 5v11a2 2 0 0 1 -2 2z"/><line x1="9" y1="9" x2="10" y2="9"/><line x1="9" y1="13" x2="15" y2="13"/><line x1="9" y1="17" x2="15" y2="17"/></svg>
            Save as TEXT
          </button>
          <a class="dropdown-item" href="https://github.com/antonmedv/textarea" target="_blank">
            <svg class="icon" viewBox="0 0 24 24"><path d="M9 19c-4.3 1.4 -4.3 -2.5 -6 -3m12 5v-3.5c0 -1 .1 -1.4 -.5 -2c2.8 -.3 5.5 -1.4 5.5 -6a4.6 4.6 0 0 0 -1.3 -3.2a4.2 4.2 0 0 0 -.1 -3.2s-1.1 -.3 -3.5 1.3a12.3 12.3 0 0 0 -6.2 0c-2.4 -1.6 -3.5 -1.3 -3.5 -1.3a4.2 4.2 0 0 0 -.1 3.2a4.6 4.6 0 0 0 -1.3 3.2c0 4.6 2.7 5.7 5.5 6c-.6 .6 -.6 1.2 -.5 2v3.5"/></svg>
            GitHub
          </a>
        </div>
      </div>
    </div>
  </nav>

  <!-- Editor -->
  <div class="editor-container">
    <article contenteditable="plaintext-only" spellcheck="true" autofocus id="editor"></article>
  </div>

  <!-- Bottom Toolbar -->
  <div class="bottom-toolbar">
    <div class="format-tools">
      <select class="format-selector" id="formatType">
        <option value="markdown">Markdown</option>
        <option value="plain">Plain Text</option>
        <option value="rich">Rich Text</option>
      </select>
      <div class="format-divider"></div>
      <button class="format-btn" id="boldBtn" title="Bold">
        <svg class="icon" viewBox="0 0 24 24"><path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"/><path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"/></svg>
      </button>
      <button class="format-btn" id="italicBtn" title="Italic">
        <svg class="icon" viewBox="0 0 24 24"><line x1="19" y1="4" x2="10" y2="4"/><line x1="14" y1="20" x2="5" y2="20"/><line x1="15" y1="4" x2="9" y2="20"/></svg>
      </button>
      <button class="format-btn" id="codeBtn" title="Code">
        <svg class="icon" viewBox="0 0 24 24"><polyline points="16 18 22 12 16 6"/><polyline points="8 6 2 12 8 18"/></svg>
      </button>
      <div class="format-divider"></div>
      <button class="format-btn" id="h1Btn" title="Heading 1">H1</button>
      <button class="format-btn" id="h2Btn" title="Heading 2">H2</button>
      <button class="format-btn" id="h3Btn" title="Heading 3">H3</button>
      <div class="format-divider"></div>
      <button class="format-btn" id="linkBtn" title="Link">
        <svg class="icon" viewBox="0 0 24 24"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"/><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"/></svg>
      </button>
      <button class="format-btn" id="listBtn" title="List">
        <svg class="icon" viewBox="0 0 24 24"><line x1="8" y1="6" x2="21" y2="6"/><line x1="8" y1="12" x2="21" y2="12"/><line x1="8" y1="18" x2="21" y2="18"/><line x1="3" y1="6" x2="3.01" y2="6"/><line x1="3" y1="12" x2="3.01" y2="12"/><line x1="3" y1="18" x2="3.01" y2="18"/></svg>
      </button>
    </div>
    <div class="stats">
      <span id="wordCount">0 words</span>
      <span id="charCount">0 chars</span>
    </div>
  </div>

  <!-- Notification -->
  <div class="notification" id="notification"></div>

  <script>
    // Initialize
    const article = document.getElementById('editor');
    const editor = new Editor(article, parseMarkdown);
    let currentFormat = 'markdown';
    let autoHideTimeout = null;

    // Load content
    addEventListener('DOMContentLoaded', load);
    addEventListener('hashchange', load);
    
    // Save on changes
    article.addEventListener('input', debounce(500, save));
    article.addEventListener('blur', save);
    
    // Update stats
    article.addEventListener('input', updateStats);
    
    // Link clicks
    article.addEventListener('click', event => {
      if (event.target.tagName === 'A') {
        window.open(event.target.getAttribute('href'), '_blank');
      }
    });

    // Mutation observer for style changes
    addEventListener('load', () => {
      new MutationObserver(save).observe(article, {attributeFilter: ['style']});
    });

    // Keyboard shortcuts
    addEventListener('keydown', e => {
      if ((e.metaKey || e.ctrlKey) && e.code === 'KeyS') {
        e.preventDefault();
        downloadHTML();
      }
      if ((e.metaKey || e.ctrlKey) && e.code === 'KeyB') {
        e.preventDefault();
        insertMarkdown('**', '**');
      }
      if ((e.metaKey || e.ctrlKey) && e.code === 'KeyI') {
        e.preventDefault();
        insertMarkdown('*', '*');
      }
    });

    // Auto-hide nav on scroll
    let lastScroll = 0;
    addEventListener('scroll', () => {
      const currentScroll = window.pageYOffset;
      const topNav = document.querySelector('.top-nav');
      const bottomBar = document.querySelector('.bottom-toolbar');
      
      if (currentScroll > lastScroll && currentScroll > 100) {
        topNav.classList.add('hidden');
        bottomBar.classList.add('hidden');
      } else {
        topNav.classList.remove('hidden');
        bottomBar.classList.remove('hidden');
      }
      lastScroll = currentScroll;
    });

    // Service Worker
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('sw.js');
    }

    // Button Handlers
    document.getElementById('newDoc').onclick = () => {
      window.open('#new', '_blank');
    };

    document.getElementById('shareBtn').onclick = async () => {
      await save();
      if (navigator.clipboard) {
        await navigator.clipboard.writeText(location.href);
        showNotification('Link copied to clipboard!');
      }
    };

    document.getElementById('menuBtn').onclick = (e) => {
      e.stopPropagation();
      const menu = document.getElementById('mainMenu');
      menu.classList.toggle('show');
    };

    document.addEventListener('click', () => {
      document.getElementById('mainMenu').classList.remove('show');
    });

    document.getElementById('qrBtn').onclick = () => {
      window.location.href = '/qr' + location.hash;
    };

    document.getElementById('saveHTML').onclick = () => {
      downloadHTML();
      document.getElementById('mainMenu').classList.remove('show');
    };

    document.getElementById('saveTXT').onclick = () => {
      downloadTXT();
      document.getElementById('mainMenu').classList.remove('show');
    };

    // Format buttons
    document.getElementById('boldBtn').onclick = () => insertMarkdown('**', '**');
    document.getElementById('italicBtn').onclick = () => insertMarkdown('*', '*');
    document.getElementById('codeBtn').onclick = () => insertMarkdown('`', '`');
    document.getElementById('h1Btn').onclick = () => insertMarkdown('# ', '\n');
    document.getElementById('h2Btn').onclick = () => insertMarkdown('## ', '\n');
    document.getElementById('h3Btn').onclick = () => insertMarkdown('### ', '\n');
    document.getElementById('linkBtn').onclick = () => insertMarkdown('[', '](url)');
    document.getElementById('listBtn').onclick = () => insertMarkdown('- ', '\n');

    document.getElementById('formatType').onchange = (e) => {
      currentFormat = e.target.value;
      if (currentFormat === 'plain') {
        article.innerHTML = article.textContent;
      } else {
        parseMarkdown(article);
      }
      save();
    };

    // Functions
    async function load() {
      try {
        if (location.hash !== '') {
          await set(location.hash);
        } else {
          await set(localStorage.getItem('hash') ?? '');
          if (article.textContent) {
            history.replaceState({}, '', await get());
          }
        }
      } catch (e) {
        article.textContent = '';
        article.removeAttribute('style');
      }
      updateTitle();
      updateStats();
    }

    async function save() {
      const hash = await get();
      if (location.hash !== hash) {
        history.replaceState({}, '', hash);
      }
      try {
        localStorage.setItem('hash', hash);
      } catch (e) {}
      updateTitle();
    }

    async function set(hash) {
      if (!hash) return;
      const [content, style] = (await decompress(hash.slice(1))).split('\x00');
      editor.set(content);
      if (style) article.setAttribute('style', style);
    }

    async function get() {
      const style = article.getAttribute('style');
      const content = article.textContent + (style !== null ? '\x00' + style : '');
      return '#' + await compress(content);
    }

    function updateTitle() {
      const match = article.textContent.match(/^\n*#(.+)\n/);
      document.title = match?.[1]?.trim() ?? 'Textarea';
    }

    function updateStats() {
      const text = article.textContent.trim();
      const words = text ? text.split(/\s+/).length : 0;
      const chars = text.length;
      document.getElementById('wordCount').textContent = `${words} word${words !== 1 ? 's' : ''}`;
      document.getElementById('charCount').textContent = `${chars} char${chars !== 1 ? 's' : ''}`;
    }

    function insertMarkdown(before, after) {
      const selection = window.getSelection();
      const range = selection.getRangeAt(0);
      const selectedText = range.toString();
      
      const wrapper = document.createTextNode(before + selectedText + after);
      range.deleteContents();
      range.insertNode(wrapper);
      
      setTimeout(() => {
        parseMarkdown(article);
        save();
      }, 10);
    }

    function showNotification(message) {
      const notif = document.getElementById('notification');
      notif.textContent = message;
      notif.classList.add('show');
      setTimeout(() => notif.classList.remove('show'), 3000);
    }

    async function compress(string) {
      const byteArray = new TextEncoder().encode(string);
      const stream = new CompressionStream('deflate-raw');
      const writer = stream.writable.getWriter();
      writer.write(byteArray);
      writer.close();
      const buffer = await new Response(stream.readable).arrayBuffer();
      return new Uint8Array(buffer).toBase64({alphabet: 'base64url'});
    }

    async function decompress(b64) {
      const byteArray = Uint8Array.fromBase64(b64, {alphabet: 'base64url'});
      const stream = new DecompressionStream('deflate-raw');
      const writer = stream.writable.getWriter();
      writer.write(byteArray);
      writer.close();
      const buffer = await new Response(stream.readable).arrayBuffer();
      return new TextDecoder().decode(buffer);
    }

    function debounce(ms, fn) {
      let timer;
      return (...args) => {
        clearTimeout(timer);
        timer = setTimeout(() => fn(...args), ms);
      };
    }

    async function downloadHTML() {
      updateTitle();
      const doc = document.documentElement.cloneNode(true);
      doc.querySelectorAll('script').forEach(s => s.remove());
      doc.querySelectorAll('.noprint, .top-nav, .bottom-toolbar').forEach(s => s.remove());
      doc.querySelector('article').removeAttribute('contenteditable');
      const html = '<!DOCTYPE html>\n' + doc.outerHTML;

      if ('showSaveFilePicker' in window) {
        try {
          const handle = await showSaveFilePicker({
            suggestedName: document.title + '.html',
            types: [{description: 'HTML file', accept: {'text/html': ['.html']}}],
          });
          const writable = await handle.createWritable();
          await writable.write(html);
          await writable.close();
          showNotification('HTML saved successfully!');
          return;
        } catch (e) {
          if (e.name === 'AbortError') return;
        }
      }

      const blob = new Blob([html], {type: 'text/html'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = document.title + '.html';
      a.click();
      URL.revokeObjectURL(url);
      showNotification('HTML downloaded!');
    }

    async function downloadTXT() {
      updateTitle();
      const text = article.textContent;

      if ('showSaveFilePicker' in window) {
        try {
          const handle = await showSaveFilePicker({
            suggestedName: document.title + '.txt',
            types: [{description: 'TEXT file', accept: {'text/plain': ['.txt']}}],
          });
          const writable = await handle.createWritable();
          await writable.write(text);
          await writable.close();
          showNotification('Text saved successfully!');
          return;
        } catch (e) {
          if (e.name === 'AbortError') return;
        }
      }

      const blob = new Blob([text], {type: 'text/plain'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = document.title + '.txt';
      a.click();
      URL.revokeObjectURL(url);
      showNotification('Text downloaded!');
    }

    function parseMarkdown(element) {
      if (currentFormat === 'plain') return;
      
      const input = element.textContent;
      const frag = document.createDocumentFragment();

      const matchers = [
        {name: 'md-codeblock', re: /```[^\n]*\n[\s\S]*?\n```/y},
        {name: 'md-codeblock', re: /~~~[^\n]*\n[\s\S]*?\n~~~/y},
        {name: 'md-h1', re: /^#[ \t]+[^\n]*$/my},
        {name: 'md-h2', re: /^##[ \t]+[^\n]*$/my},
        {name: 'md-h3', re: /^###[ \t]+[^\n]*$/my},
        {name: 'md-h4', re: /^####[ \t]+[^\n]*$/my},
        {name: 'md-h5', re: /^#####[ \t]+[^\n]*$/my},
        {name: 'md-h6', re: /^######[ \t]+[^\n]*$/my},
        {name: 'md-code', re: /`[^`\n]*`/y},
        {name: 'md-bold', re: /\*\*[^*\n]+?\*\*/y},
        {name: 'md-bold', re: /__[^_\n]+?__/y},
        {name: 'md-strike', re: /~~[^~\n]+?~~/y},
        {name: 'md-italic', re: /\*[^*\n]+?\*/y},
        {name: 'md-italic', re: /_[^_\n]+?_/y},
        {name: 'md-url', re: /https?:\/\/[^\s<>()\[\]{}"'`]+/y},
      ];

      const specials = ['`', '~', '*', '#', '_', 'h'];

      let i = 0;
      while (i < input.length) {
        let matched = false;
        for (const m of matchers) {
          m.re.lastIndex = i;
          const res = m.re.exec(input);
          if (res && res.index === i) {
            const raw = res[0];
            if (m.name === 'md-url') {
              const a = document.createElement('a');
              a.className = 'md-url';
              a.href = raw;
              a.textContent = raw;
              a.target = '_blank';
              a.rel = 'noopener noreferrer';
              frag.appendChild(a);
            } else {
              const span = document.createElement('span');
              span.className = m.name;
              span.textContent = raw;
              frag.appendChild(span);
            }
            i += raw.length;
            matched = true;
            break;
          }
        }

        if (matched) continue;

        let next = input.length;
        for (const ch of specials) {
          const idx = input.indexOf(ch, i);
          if (idx !== -1 && idx < next) next = idx;
        }

        if (next === i) {
          frag.appendChild(document.createTextNode(input[i]));
          i++;
          continue;
        }

        frag.appendChild(document.createTextNode(input.slice(i, next)));
        i = next;
      }

      article.textContent = '';
      article.appendChild(frag);
      article.normalize();
    }

    function Editor(element, highlight) {
      const listeners = [];
      const history = [];
      let at = -1, prev;

      const debounceHighlight = debounce(30, () => {
        const pos = save();
        highlight(element);
        restore(pos);
      });

      const shouldRecord = (event) => {
        return !isUndo(event) && !isRedo(event)
          && event.key !== 'Meta'
          && event.key !== 'Control'
          && event.key !== 'Alt'
          && !event.key.startsWith('Arrow');
      };

      let recording = false;
      const debounceRecordHistory = debounce(300, (event) => {
        if (shouldRecord(event)) {
          recordHistory();
          recording = false;
        }
      });

      const on = (type, fn) => {
        listeners.push([type, fn]);
        element.addEventListener(type, fn);
      };

      on('keydown', event => {
        if (event.defaultPrevented) return;
        prev = toString();
        if (isUndo(event)) doUndo(event);
        if (isRedo(event)) doRedo(event);
        if (shouldRecord(event) && !recording) {
          recordHistory();
          recording = true;
        }
      });

      on('keyup', event => {
        if (event.defaultPrevented) return;
        if (event.isComposing) return;
        if (prev !== toString()) debounceHighlight();
        debounceRecordHistory(event);
      });

      on('paste', () => setTimeout(recordHistory, 10));
      on('cut', () => setTimeout(recordHistory, 10));
      on('beforeinput', event => {
        if (event.inputType === 'historyUndo') doUndo(event);
        if (event.inputType === 'historyRedo') doRedo(event);
      });

      function save() {
        const s = getSelection();
        const pos = {start: 0, end: 0, dir: undefined};
        let {anchorNode, anchorOffset, focusNode, focusOffset} = s;
        if (!anchorNode || !focusNode) throw 'error1';
        if (anchorNode === element && focusNode === element) {
          pos.start = (anchorOffset > 0 && element.textContent) ? element.textContent.length : 0;
          pos.end = (focusOffset > 0 && element.textContent) ? element.textContent.length : 0;
          pos.dir = (focusOffset >= anchorOffset) ? '->' : '<-';
          return pos;
        }
        if (anchorNode.nodeType === Node.ELEMENT_NODE) {
          const node = document.createTextNode('');
          anchorNode.insertBefore(node, anchorNode.childNodes[anchorOffset]);
          anchorNode = node;
          anchorOffset = 0;
        }
        if (focusNode.nodeType === Node.ELEMENT_NODE) {
          const node = document.createTextNode('');
          focusNode.insertBefore(node, focusNode.childNodes[focusOffset]);
          focusNode = node;
          focusOffset = 0;
        }
        visit(element, el => {
          if (el === anchorNode && el === focusNode) {
            pos.start += anchorOffset;
            pos.end += focusOffset;
            pos.dir = anchorOffset <= focusOffset ? '->' : '<-';
            return 'stop';
          }
          if (el === anchorNode) {
            pos.start += anchorOffset;
            if (!pos.dir) {
              pos.dir = '->';
            } else {
              return 'stop';
            }
          } else if (el === focusNode) {
            pos.end += focusOffset;
            if (!pos.dir) {
              pos.dir = '<-';
            } else {
              return 'stop';
            }
          }
          if (el.nodeType === Node.TEXT_NODE) {
            if (pos.dir !== '->') pos.start += el.nodeValue.length;
            if (pos.dir !== '<-') pos.end += el.nodeValue.length;
          }
        });

        element.normalize();
        return pos;
      }

      function restore(pos) {
        const s = getSelection();
        let startNode, startOffset = 0;
        let endNode, endOffset = 0;

        if (!pos.dir) pos.dir = '->';
        if (pos.start < 0) pos.start = 0;
        if (pos.end < 0) pos.end = 0;

        if (pos.dir === '<-') {
          const {start, end} = pos;
          pos.start = end;
          pos.end = start;
        }

        let current = 0;

        visit(element, el => {
          if (el.nodeType !== Node.TEXT_NODE) return;

          const len = (el.nodeValue || '').length;
          if (current + len > pos.start) {
            if (!startNode) {
              startNode = el;
              startOffset = pos.start - current;
            }
            if (current + len > pos.end) {
              endNode = el;
              endOffset = pos.end - current;
              return 'stop';
            }
          }
          current += len;
        });

        if (!startNode) {
          startNode = element;
          startOffset = element.childNodes.length;
        }
        if (!endNode) {
          endNode = element;
          endOffset = element.childNodes.length;
        }

        if (pos.dir === '<-') {
          [startNode, startOffset, endNode, endOffset] = [endNode, endOffset, startNode, startOffset];
        }

        {
          const startEl = uneditable(startNode);
          if (startEl) {
            const node = document.createTextNode('');
            startEl.parentNode?.insertBefore(node, startEl);
            startNode = node;
            startOffset = 0;
          }
          const endEl = uneditable(endNode);
          if (endEl) {
            const node = document.createTextNode('');
            endEl.parentNode?.insertBefore(node, endEl);
            endNode = node;
            endOffset = 0;
          }
        }

        s.setBaseAndExtent(startNode, startOffset, endNode, endOffset);
        element.normalize();
      }

      function uneditable(node) {
        while (node && node !== element) {
          if (node.nodeType === Node.ELEMENT_NODE) {
            if (node.getAttribute('contenteditable') === 'false') {
              return node;
            }
          }
          node = node.parentNode;
        }
      }

      function doUndo(event) {
        preventDefault(event);
        at--;
        const record = history[at];
        if (record) {
          element.innerHTML = record.html;
          restore(record.pos);
        }
        if (at < 0) at = 0;
      }

      function doRedo(event) {
        preventDefault(event);
        at++;
        const record = history[at];
        if (record) {
          element.innerHTML = record.html;
          restore(record.pos);
        }
        if (at >= history.length) at--;
      }

      function recordHistory() {
        const html = element.innerHTML;
        const pos = save();
        const lastRecord = history[at];
        if (
          lastRecord
          && lastRecord.html === html
          && lastRecord.pos.start === pos.start
          && lastRecord.pos.end === pos.end
        ) return;
        at++;
        history[at] = {html, pos};
        history.splice(at + 1);
        const maxHistory = 10_000;
        if (at > maxHistory) {
          at = maxHistory;
          history.splice(0, 1);
        }
      }

      function visit(editor, visitor) {
        const queue = [];
        if (editor.firstChild) queue.push(editor.firstChild);
        let el = queue.pop();
        while (el) {
          if (visitor(el) === 'stop') break;
          if (el.nextSibling) queue.push(el.nextSibling);
          if (el.firstChild) queue.push(el.firstChild);
          el = queue.pop();
        }
      }

      function isCtrl(event) {
        return event.metaKey || event.ctrlKey;
      }

      function isUndo(event) {
        return isCtrl(event) && !event.shiftKey && event.code === 'KeyZ';
      }

      function isRedo(event) {
        return isCtrl(event) && event.shiftKey && event.code === 'KeyZ';
      }

      function toString() {
        return element.textContent || '';
      }

      function preventDefault(event) {
        event.preventDefault();
      }

      function getSelection() {
        return element.getRootNode().getSelection();
      }

      return {
        set(content) {
          element.textContent = content;
          highlight(element);
        },
        destroy() {
          for (const [type, fn] of listeners) element.removeEventListener(type, fn);
        },
      };
    }

    console.log('%cEnhanced Textarea - GitHub: https://github.com/antonmedv/textarea', 'font-size: 14px; color: #3b82f6; font-weight: bold; padding: 10px;');
  </script>
</body>
</html>